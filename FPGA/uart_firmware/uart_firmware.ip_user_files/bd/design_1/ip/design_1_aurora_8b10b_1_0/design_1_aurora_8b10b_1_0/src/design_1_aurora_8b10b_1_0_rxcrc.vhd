------------------------------------------------------------------------------
-- Project:  Aurora 8B/10B
-- Version:  version 11.0
-- Company:  Xilinx 
--
--
-- (c) Copyright 2012 - 2013 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.

--
--------------------------------------------------------------------------------
--
-- Module design_1_aurora_8b10b_1_0_RX_CRC
-- Generated by Xilinx Aurora 8B10B
---------------------------------------------------------------------
-- Library Declarations
---------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;

---------------------------------------------------------------------
----port declarations
---------------------------------------------------------------------
ENTITY design_1_aurora_8b10b_1_0_RX_CRC IS
PORT
  (
DATA_DS                        :  OUT std_logic_vector(31 downto 0);
REM_DS                         :  OUT std_logic_vector(1 downto 0); 
    SOF_N_DS                       :  OUT std_logic;
    EOF_N_DS                       :  OUT std_logic;
    SRC_RDY_N_DS                   :  OUT std_logic;
    DST_RDY_N_US                   :  OUT std_logic;
    CRC_PASS_FAIL_N                :  OUT std_logic;
    CRC_VALID                      :  OUT std_logic;
DATA_US                        :  IN  std_logic_vector(31 downto 0);
REM_US                         :  IN  std_logic_vector(1 downto 0); 
    SOF_N_US                       :  IN  std_logic;
    EOF_N_US                       :  IN  std_logic;
    SRC_RDY_N_US                   :  IN  std_logic;
    DST_RDY_N_DS                   :  IN  std_logic;
    RESET                          :  IN  std_logic;
    CLK                            :  IN  std_logic
  );
END design_1_aurora_8b10b_1_0_RX_CRC;

ARCHITECTURE RX_CRC_ARCH of design_1_aurora_8b10b_1_0_RX_CRC is

    constant DLY : time := 1 ns;

--__Signal declaration for one-hot encoded FSM__

signal  idle_r      : std_logic;
signal  wait_r      : std_logic;
signal  sof_ds_r    : std_logic;
signal  data_r      : std_logic;
signal  eof_ds_r    : std_logic;
signal  sof_eof_r   : std_logic;

signal  idle_c      : std_logic;
signal  wait_c      : std_logic;
signal  sof_ds_c    : std_logic;
signal  data_c      : std_logic;
signal  eof_ds_c    : std_logic;
signal  sof_eof_c   : std_logic;

signal  rem_in      : std_logic_vector(1 downto 0);  --store input REM
signal  SOF_N_US_r  : std_logic;                    --SOF delayed by one cycle
signal  EOF_N_US_r  : std_logic;                    --EOF delayed by one cycle
signal  count       : std_logic_vector (1 downto 0);    --count to deassert dst-rdy-us after receiving EOF
signal  DATA_US_r   : std_logic_vector(31 downto 0); --data input pipeline-I
signal  DATA_US_2r  : std_logic_vector(31 downto 0); --data input pipeine-II

signal  SRC_RDY_N_US_2r : std_logic;
signal  ll_valid_r      : std_logic;
signal  received_CRC    : std_logic_vector(31 downto 0);   --CRC output registered from CRC block
signal  CRC_RESET_r		: std_logic;
   
signal  DST_RDY_N_US_i  : std_logic;
signal  ll_valid        : std_logic;    --__LocalLink valid
signal  CRC1             : std_logic_vector(31 downto 0);   --__CRC calculated for lane1
signal  CRC_RESET       : std_logic;    --__reset to CRC block
  signal  CRC_DATAWIDTH1   : std_logic_vector (1 downto 0);  --__CRC datawidth for lane1
signal  CRC_DATAVALID             : std_logic;   --__CRC datavalid
signal  CRC_DATAVALID1             : std_logic;   --__CRC datavalid for lane1
signal  CRC_DATA1        : std_logic_vector(31 downto 0); --__data input to CRC block for lane1
signal  final_CRC       : std_logic_vector(31 downto 0);
signal  tx_crc          : std_logic_vector(31 downto 0);
signal  crc_datawidth1_temp   : std_logic_vector(1 downto 0);  --__CRC datawidth temp signal for lane1
signal  crc_datavalid1_temp   : std_logic;  --__CRC datavalid temp signal for lane1
signal  tied_to_ground        :   std_logic_vector(31 downto 0);
signal  data_us_temp1         : std_logic_vector(31 downto 0);
signal  data_us_temp2         : std_logic_vector(31 downto 0);

  component design_1_aurora_8b10b_1_0_CRC_TOP
  generic (
    CRC_INIT   : bit_vector := X"FFFFFFFF"
     );   
  port (
    CRCOUT            : out std_logic_vector(31 downto 0);
 
    CRCCLK            : in  std_ulogic;
    CRCDATAVALID      : in  std_ulogic;
    CRCDATAWIDTH      : in  std_logic_vector(1 downto 0);
    CRCIN             : in  std_logic_vector(31 downto 0);
    CRCRESET          : in  std_ulogic
  );
  end component; 

    --____________Main code begins here________________--
begin   
    --__Initialization & state assignment for FSM__--

  process (CLK)
      begin
        if (CLK'event and CLK = '1') then
          if (RESET = '1') then
            idle_r        <=  '1' after DLY;
            wait_r        <=  '0' after DLY;
            sof_eof_r     <=  '0' after DLY;
            sof_ds_r      <=  '0' after DLY;
            data_r        <=  '0' after DLY;
            eof_ds_r      <=  '0' after DLY;
          elsif (DST_RDY_N_DS = '0') then
            idle_r        <=  idle_c after DLY;
            wait_r        <=  wait_c after DLY;
            sof_eof_r     <=  sof_eof_c after DLY;
            sof_ds_r      <=  sof_ds_c after DLY;
            data_r        <=  data_c after DLY;
            eof_ds_r      <=  eof_ds_c after DLY;
         end if;
        end if;
  end process;

  --__Combinatorial logic for FSM__--
  idle_c  <= (idle_r or eof_ds_r or sof_eof_r) and (SOF_N_US or (not ll_valid));
               
  wait_c  <= ((idle_r or eof_ds_r or sof_eof_r) and ((not SOF_N_US) and ll_valid)) or (wait_r and (not ll_valid));
     
  sof_eof_c <= wait_r and (not EOF_N_US) and ll_valid;
     
  sof_ds_c  <= wait_r and EOF_N_US and ll_valid;
     
  data_c  <= ((sof_ds_r or data_r) and (EOF_N_US or (not ll_valid)));
               
  eof_ds_c  <= ((data_r or sof_ds_r) and (not EOF_N_US) and ll_valid);
 
  --__Store REM value and build output REM__
  process (CLK)
    begin
    if (CLK'event and CLK = '1') then
      if ((not EOF_N_US and ll_valid)='1') then
        rem_in    <=  REM_US after DLY;        --input REM storage
      end if;
    end if;
  end process;

process (CLK)
  begin
  if (CLK'event and CLK = '1') then
    if (ll_valid='1') then
      EOF_N_US_r  <=  EOF_N_US after DLY;
      SOF_N_US_r  <=  SOF_N_US after DLY;
      DATA_US_r   <=  DATA_US after DLY;
    end if;
  end if;
end process;

process (CLK)
  begin
  if (CLK'event and CLK = '1') then
    if ((not DST_RDY_N_DS or not EOF_N_US_r)='1') then
      DATA_US_2r   <=  DATA_US_r after DLY;
      SRC_RDY_N_US_2r  <=  not CRC_DATAVALID after DLY;
    end if;
  end if;
end process;

   process (CLK)
   begin
      if (CLK'event and CLK = '1') then
         if (((not SOF_N_US_r) and EOF_N_US_r and ll_valid_r) = '1') then
            CRC_RESET_r <= not ll_valid after DLY;
         elsif ((ll_valid and CRC_RESET_r) = '1') then
            CRC_RESET_r <= '0' after DLY;
         end if;
      end if;
   end process;

  CRC_RESET     <= (ll_valid or (not EOF_N_US_r)) when (((not SOF_N_US_r) and ll_valid_r) = '1') else
                   (ll_valid and CRC_RESET_r);
               
  CRC_DATAVALID <= '0' when ((((not SOF_N_US) and ll_valid) = '1') or (((not EOF_N_US_r) and ll_valid_r)='1')) else
                   (ll_valid or CRC_RESET);

    CRC_DATAWIDTH1      <= REM_US(1 downto 0) when (((not EOF_N_US) and ll_valid) = '1') else
                                   "11";
    CRC_DATAVALID1      <= CRC_DATAVALID;
    CRC_DATA1           <= DATA_US_r(31 downto 0);
      
   --CRC block instantiation for lane1
   rx_crc_gen1_i : design_1_aurora_8b10b_1_0_CRC_TOP
   generic map (
                           CRC_INIT                =>  x"FFFFFFFF"
               )
   port map    (
  
      CRCRESET          =>  CRC_RESET, 
      CRCCLK            =>  CLK,
      --CRCDATAWIDTH      =>  CRC_DATAWIDTH1,
      --CRCDATAVALID      =>  CRC_DATAVALID1,   
      --CRCIN             =>  CRC_DATA1,  
      --CRCOUT            =>  CRC1
      CRCDATAWIDTH      =>  CRC_DATAWIDTH1,
      CRCDATAVALID      =>  CRC_DATAVALID1,   
      CRCIN             =>  CRC_DATA1,  
      CRCOUT            =>  CRC1

   );

  final_CRC <= (
                 CRC1 );

    --deassert dst-rdy-us after EOF reception or when dst-rdy-ds is deasserted--
    DST_RDY_N_US    <=  DST_RDY_N_US_i;
    DST_RDY_N_US_i  <=  DST_RDY_N_DS  or count(0) or count(1) or RESET;
   
    --__deassert dst_rdy_n_us for 2 cycles after eof_n_us reception
    -- to take care of crc insertion in DS-data__
    process (CLK)
    begin
      if (CLK'event and CLK = '1') then
        if (RESET = '1') then
          count   <=  "00" after DLY;
        elsif ((ll_valid and (not EOF_N_US))='1') then
          count   <=  "01" after DLY;
        elsif ((DST_RDY_N_DS='0') and (count /= "00")) then
          count   <= '0' &  count(1) after DLY;
        end if;
      end if;
    end process;
   
  ll_valid <= not (SRC_RDY_N_US or DST_RDY_N_US_i);
   
  process (CLK)
  begin
    if (CLK'event and CLK = '1') then
      ll_valid_r  <=  ll_valid after DLY;
    end if;
  end process;
 
  --__Build DS output__--
    process (CLK)
    begin
      if (CLK'event and CLK = '1') then
        if (RESET = '1') then
          SOF_N_DS  <=  '1' after DLY;
          EOF_N_DS  <=  '1' after DLY;
          SRC_RDY_N_DS  <=  '1' after DLY;
          DATA_DS   <=  (others => '0') after DLY;
        elsif (DST_RDY_N_DS='0') then
          SOF_N_DS  <=  not (sof_eof_r or sof_ds_r) after DLY;
          EOF_N_DS  <=  not (sof_eof_r or eof_ds_r) after DLY;
          SRC_RDY_N_DS  <=  SRC_RDY_N_US_2r after DLY;
          DATA_DS <=  DATA_US_2r after DLY;
        end if;
      end if;
    end process;

	process (CLK)
   begin
      if (CLK'event and CLK = '1') then
         if (RESET = '1') then
REM_DS   <= "11" after DLY;
         elsif ((sof_eof_r or eof_ds_r)='1') then
            REM_DS   <= rem_in after DLY;
         else
REM_DS   <= "11" after DLY;
         end if;
      end if;
   end process;

  --__Extract CRC from input data__--
   
    --__CRC extraction for all other cases__--
  tx_crc <=
(DATA_US_r(23 downto 0) & DATA_US(31 downto 24)) when (REM_US = "00")   else 
(DATA_US_r(15 downto 0) & DATA_US(31 downto 16)) when (REM_US = "01")   else 
(DATA_US_r(7 downto 0) & DATA_US(31 downto 8)) when (REM_US = "10")   else DATA_US(31 downto 0); 
     
      --__store the received CRC__--
  process (CLK)
  begin
    if (CLK'event and CLK = '1') then
      if ((not EOF_N_US and ll_valid)='1') then
        received_CRC  <=  tx_crc after DLY;
      end if;
    end if;
  end process;

  --__compare the received CRC with the CRC calculated__--
  CRC_PASS_FAIL_N  <= '1' when (received_CRC = final_CRC) else '0';

  --__CRC_PASS_FAIL_N to be considered only when CRC_VALID is asserted__--
  process (CLK)
  begin
    if (CLK'event and CLK = '1') then
      if (RESET='1') then
         CRC_VALID <=  '0' after DLY;
      else
         CRC_VALID <=  (sof_eof_r or eof_ds_r) after DLY;
      end if;
    end if;
  end process;

END RX_CRC_ARCH;
